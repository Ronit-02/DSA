# Coding Patterns

### 1. Fast and slow Pointers
- `input` 
- `output` 
- `ques` 

### 2. Merge Intervals
- `input` intervals
- `output` mutually exclusive intervals, overlapping intervals
- `ques` merge intervals, max cpu load, insert interval

### 3. Two pointers 
- `input` sorted array
- `output` 
- `ques` 

### 4. Sliding Window
- `input` array, ll, string
- `output` to find longest/shortest substr, subarr,..
- `ques` longest subarr of size k, longest substr with k dist char, string anagram

### 5. Cyclic Sort
- `input` sorted array in give range
- `output` missing/duplicate/smallest element in sorted/rotated array
- `ques` missing no, duplicates in array

### 6. Tree BFS
- `input` 
- `output` 
- `ques` 

### 7. In-place reversal of Linked List
- `input` 
- `output` 
- `ques` 

### 8. Top k elements
- `input` 
- `output` 
- `ques` 

### 9. Tree DFS
- `input` 
- `output` 
- `ques` 

### 10. Modified Binary Search
- `input` 
- `output` 
- `ques`

### 11. Two Heaps
- `input` top, maximum, minimum, closest 'k' elements
- `output` 
- `ques` 

### 12. Subsets
- `input` 
- `output` 
- `ques` 

### 13. K-ways Merge
- `input` 
- `output` 
- `ques` 

### 14. Topological Sort 
- `input` use graph in relation questions
- `output` 
- `ques` 

### 15. Hashmaps 
- available / required
- `input` 
- `output` 
- `ques` 

### 16. Greedy Techniques
- greedy sorting
- `input` 
- `output` 
- `ques` 

### 17. Backtracking
- `input` 
- `output` 
- `ques` 

### 18. DP
- `input` 
- `output` 
- `ques` 

### 19. Stacks
- `input` 
- `output` 
- `ques` 

### 20. Trie
- `input` 
- `output` 
- `ques` 

### 21. Knowing what to track
- `input` 
- `output` 
- `ques` 

### 22. Union Find
- `input` 
- `output` 
- `ques` 

### 23. Bitwise Manipulation
- `input` 
- `output` 
- `ques` 

## Others
1. Given some relation ask to divide into 2 grps, use Graph Coloring problem or Bipartite Graph DFS/BFS

2. Most ques related to Trees / Graphs can be solved either through BFS / DFS

3. Recursive solution -> iterative using stack

4. For array problem if there exists a O(n^2) soln, then there will be 2 more solutions
- O(n), O(n) solution using hashmap or set
- O(nlogn) solution using sorting

5. If a problem is asking for optimization (e.g., maximization or minimization), we will be using Dynamic Programming.

6. If we need to search/manipulate a bunch of strings, Trie will be the best data structure.